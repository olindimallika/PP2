import prisma from '../../../utils/db';
import { verifyToken } from '../../../utils/auth';

export default async function handler(req, res) {
    const { method } = req;

    //check if user is authenticated
    const verifiedUser = verifyToken(req.headers.authorization);
    if (!verifiedUser) {
        return res.status(401).json({ error: 'Unauthorized or invalid token. Please log-in!' });
    }

    const userId = verifiedUser.userId;

    if (method === 'POST') {//POST = create a new blog post

        const { title, description, tags, templateIds } = req.body;

        if (!title || !description) {
            return res.status(400).json({ error: 'Please fill in title and description.' });
        }

        //try catch block generated by ChatGPT and Copilot autofill, prompt was "write a try catch block to handle creating a blog post with a title, description, tags, and templates".
        try {
            //make blog post with the templates and tags
            const blogPost = await prisma.blogPost.create({
                data: {
                    title,
                    description,
                    userId,
                    tags: {
                        create: tags.map(tag => ({ name: tag }))
                    },
                    templates: {
                        connect: templateIds.map(id => ({ id })) // Link to existing templates by ID
                    }
                },
                include: { tags: true, templates: true }
            });

            return res.status(201).json({ message: 'Blog post created successfully!', blogPost });
        } catch (error) {
            console.error("Error creating blog post:", error);
            return res.status(500).json({ error: 'Error creating blog post' });
        }
    } else if (method === 'PUT') {// PUT = edit an existing blog post
        const { id, title, description, tags, templateIds } = req.body;

        if (!id || (!title && !description && !tags && !templateIds)) {
            return res.status(400).json({ error: 'Please provide the blog post ID and at least one field to update.' });
        }

        //try catch block generated by ChatGPT and Copilot autofill, prompt was "write a try catch block to handle editing a blog post with a title, description, tags, and templates".
        try {
            //update the blog post with the specified fields
            const blogPost = await prisma.blogPost.update({
                where: { 
                    id: Number(id),
                    isHidden: false // only allow the author to edit blog posts that are not hidden

                },
                data: {
                    title,
                    description,
                    tags: {
                        deleteMany: {}, // Delete old tags
                        create: tags.map(tag => ({ name: tag })) // Add new tags
                    },
                    templates: {
                        set: templateIds.map(id => ({ id })) // Update linked templates
                    }
                },
                include: { tags: true, templates: true }
            });

            return res.status(200).json({ message: 'Blog post updated successfully!', blogPost });
        } catch (error) {
            console.error("Error updating blog post:", error);
            return res.status(500).json({ error: 'Error updating blog post' });
        }
    } else if (method === 'DELETE') {//DELETE = Delete a blog post
        const { id } = req.body;

        if (!id) {
            return res.status(400).json({ error: 'Blog post ID is required.' });
        }

        //try catch block generated by ChatGPT and Copilot autofill, prompt was "write a try catch block to handle deleting a blog post".
        try {
            // Delete associated tags, comments, and ratings before deleting the blog post
            await prisma.blogPostTag.deleteMany({ where: { blogPostId: Number(id) } });
            await prisma.comment.deleteMany({ where: { blogPostId: Number(id) } });
            await prisma.rating.deleteMany({ where: { blogPostId: Number(id) } });
    
            //deleting the blog post itself
            await prisma.blogPost.delete({
                where: { id: Number(id) }
            });
    
            return res.status(200).json({ message: 'Blog post deleted successfully!' });
        } catch (error) {
            console.error("Error deleting blog post:", error);
            return res.status(500).json({ error: 'Error deleting blog post' });
        }
    } else {
        res.status(405).json({ error: 'Method not allowed' });
    }
}